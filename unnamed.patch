Index: src/main/java/com/tai/demo/DemoApplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/DemoApplication.java	(date 1599530348760)
+++ src/main/java/com/tai/demo/DemoApplication.java	(date 1599530348760)
@@ -0,0 +1,14 @@
+package com.tai.demo;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+
+@SpringBootApplication
+public class DemoApplication {
+
+	public static void main(String[] args) {
+		SpringApplication.run(DemoApplication.class, args);
+		System.out.println("hello springboot!!");
+	}
+
+}
Index: src/main/resources/logback-spring.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/resources/logback-spring.xml	(date 1599551510984)
+++ src/main/resources/logback-spring.xml	(date 1599551510984)
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<configuration debug="false">
+    <!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径-->
+    <property name="LOG_HOME" value="C:/Logs" />
+    <!-- 控制台输出 -->
+    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
+            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
+            <pattern>%red(%date{yyyy-MM-dd HH:mm:ss}) %highlight(%-5level) %red([%thread]) %boldMagenta(%logger{50}) %cyan(%msg%n)</pattern>
+        </encoder>
+    </appender>
+    <!-- 按照每天生成日志文件 -->
+    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
+        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
+            <!--日志文件输出的文件名-->
+            <FileNamePattern>${LOG_HOME}/log.%d{yyyy-MM-dd_HH}.log</FileNamePattern>
+            <!--日志文件保留天数-->
+            <MaxHistory>30</MaxHistory>
+        </rollingPolicy>
+        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
+            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
+            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
+        </encoder>
+        <!--日志文件最大的大小-->
+        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
+            <MaxFileSize>10MB</MaxFileSize>
+        </triggeringPolicy>
+    </appender>
+
+    <!-- 日志输出级别 -->
+    <root level="INFO">
+        <appender-ref ref="STDOUT" />
+        <appender-ref ref="FILE" />
+    </root>
+</configuration>
\ No newline at end of file
Index: src/main/resources/application-dev.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- src/main/resources/application-dev.properties	(date 1599546209655)
+++ src/main/resources/application-dev.properties	(date 1599546209655)
@@ -0,0 +1,10 @@
+server.port=9090
+server.servlet.context-path=/springboot
+server.servlet.session.timeout=300
+
+logging.level.root:debug
+logging.config=classpath:logback-spring.xml
+
+book.author=lidengtai
+book.name=springboot
+book.age=30
Index: in/2.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- in/2.txt	(date 1603790626059)
+++ in/2.txt	(date 1603790626059)
@@ -0,0 +1,3 @@
+hello hive
+hello hbase
+hello hadoop
\ No newline at end of file
Index: in/1.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- in/1.txt	(date 1603790212061)
+++ in/1.txt	(date 1603790212061)
@@ -0,0 +1,3 @@
+hello scala
+hello spark
+hello hadoop
\ No newline at end of file
Index: src/test/java/com/tai/demo/DemoApplicationTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/com/tai/demo/DemoApplicationTests.java	(date 1599352084000)
+++ src/test/java/com/tai/demo/DemoApplicationTests.java	(date 1599352084000)
@@ -0,0 +1,13 @@
+package com.tai.demo;
+
+import org.junit.jupiter.api.Test;
+import org.springframework.boot.test.context.SpringBootTest;
+
+@SpringBootTest
+class DemoApplicationTests {
+
+	@Test
+	void contextLoads() {
+	}
+
+}
Index: src/main/java/com/tai/hbase/HbaseAPI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/hbase/HbaseAPI.java	(date 1603260576028)
+++ src/main/java/com/tai/hbase/HbaseAPI.java	(date 1603260576028)
@@ -0,0 +1,54 @@
+package com.tai.hbase;
+
+import org.apache.catalina.LifecycleState;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HBaseConfiguration;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.*;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @description: Hbase的API
+ * @author: Taylor
+ * @date :  2020-10-16 14:50
+ **/
+public class HbaseAPI {
+
+    private static Configuration configuration = null;
+    private static Connection connection  = null;
+
+    static {
+        try {
+            configuration = HBaseConfiguration.create();
+            configuration.set("hbase.zookeeper.quorum","hadoop01,hadoop02,hadoop03");
+            connection = ConnectionFactory.createConnection(configuration);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * 表是否存在
+     * @param table
+     * @return
+     * @throws IOException
+     */
+    public static boolean isExistsTable(String table) throws IOException {
+
+        /**
+         * getAdmin ddl操作对象
+         *  Admin admin  = connection.getAdmin();
+         * getTable dml操作对象
+         * Table table = connection.getTable(TableName.valueOf(table))
+         */
+        Admin admin  = connection.getAdmin();
+        boolean b = admin.tableExists(TableName.valueOf(table));
+        admin.close();
+
+        return b;
+    }
+
+}
Index: src/main/scala/com/taylor/spark/SparkRDD.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/scala/com/taylor/spark/SparkRDD.scala	(date 1603846729580)
+++ src/main/scala/com/taylor/spark/SparkRDD.scala	(date 1603846729580)
@@ -0,0 +1,27 @@
+package com.taylor.spark
+
+import org.apache.spark.rdd.RDD
+import org.apache.spark.{SparkConf, SparkContext}
+
+/**
+  * @description: RDD demo
+  * @author: Taylor
+  * @date :  2020-10-27 15:17
+  **/
+object SparkRDD {
+
+  def main(args: Array[String]): Unit = {
+
+    val sparkConf: SparkConf = new SparkConf().setMaster("local[*]").setAppName("SPARK-RDD-DEMO")
+
+    val sc = new SparkContext(sparkConf)
+
+    //创建RDD: 从内存中创建makeRDD 底层实现parallelize
+//    val listRDD: RDD[Int] = sc.makeRDD(List(1,2,3,4,5,6,7,8,9,10,11))
+
+    //从外部存储中创建
+    val fileRDD: RDD[(String, Int)] = sc.textFile("in",4).flatMap(_.split(" ")).map((_,1)).reduceByKey(_+_)
+
+    fileRDD.saveAsTextFile("output")
+  }
+}
Index: src/main/resources/application.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- src/main/resources/application.properties	(date 1599529719743)
+++ src/main/resources/application.properties	(date 1599529719743)
@@ -0,0 +1,2 @@
+spring.profiles.active=dev
+debug=true
\ No newline at end of file
Index: src/main/scala/com/taylor/spark/SparkDemo.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/scala/com/taylor/spark/SparkDemo.scala	(date 1603791371935)
+++ src/main/scala/com/taylor/spark/SparkDemo.scala	(date 1603791371935)
@@ -0,0 +1,26 @@
+package com.taylor.spark
+
+import org.apache.spark.rdd.RDD
+import org.apache.spark.{SparkConf, SparkContext}
+
+/**
+  * @description: spark WordCount demo
+  * @author: Taylor
+  * @date :  2020-10-27 09:39
+  **/
+object SparkDemo {
+  def main(args: Array[String]): Unit = {
+    val config : SparkConf = new SparkConf().setMaster("local[*]").setAppName("WordCount")
+
+    val sc = new SparkContext(config)
+
+    val lines: RDD[String] = sc.textFile("in")
+
+    val words: RDD[String] = lines.flatMap(_.split(" "))
+
+    val wordToOne: RDD[(String, Int)] = words.map((_,1))
+
+    val result: RDD[(String, Int)] = wordToOne.reduceByKey(_+_)
+    result.collect().foreach(println)
+  }
+}
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- pom.xml	(date 1603854215679)
+++ pom.xml	(date 1603854215679)
@@ -0,0 +1,118 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.springframework.boot</groupId>
+		<artifactId>spring-boot-starter-parent</artifactId>
+		<version>2.3.3.RELEASE</version>
+		<relativePath/> <!-- lookup parent from repository -->
+	</parent>
+	<groupId>com.tai</groupId>
+	<artifactId>taylor</artifactId>
+	<version>0.0.1-SNAPSHOT</version>
+	<name>taylor</name>
+	<description>Demo project for taylor</description>
+
+	<properties>
+		<java.version>1.8</java.version>
+		<hbase.version>1.3.1</hbase.version>
+	</properties>
+
+	<dependencies>
+		<!--springboot相关jar包-->
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter</artifactId>
+		</dependency>
+		
+		<dependency>
+		        <groupId>org.springframework.boot</groupId>
+		        <artifactId>spring-boot-starter-web</artifactId>
+		 </dependency>
+		 
+		 <dependency>
+		        <groupId>org.springframework.boot</groupId>
+		        <artifactId>spring-boot-starter-tomcat</artifactId>
+		 </dependency>
+		 
+		 <dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-configuration-processor</artifactId>
+			<optional>true</optional>
+		</dependency>
+		
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-aop</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-thymeleaf</artifactId>
+		</dependency>
+
+		<!--hbase相关jar包-->
+		<dependency>
+			<groupId>org.apache.hbase</groupId>
+			<artifactId>hbase-client</artifactId>
+			<version>${hbase.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.hbase</groupId>
+			<artifactId>hbase-server</artifactId>
+			<version>${hbase.version}</version>
+		</dependency>
+
+		<!--spark相关jar包-->
+		<dependency>
+			<groupId>org.apache.spark</groupId>
+			<artifactId>spark-core_2.11</artifactId>
+			<version>2.2.0</version>
+		</dependency>
+
+		<dependency>
+			<groupId>org.springframework.boot</groupId>
+			<artifactId>spring-boot-starter-test</artifactId>
+			<scope>test</scope>
+			<exclusions>
+				<exclusion>
+					<groupId>org.junit.vintage</groupId>
+					<artifactId>junit-vintage-engine</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+
+	</dependencies>
+
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.springframework.boot</groupId>
+				<artifactId>spring-boot-maven-plugin</artifactId>
+			</plugin>
+			<!--scala插件-->
+			<plugin>
+				<groupId>net.alchim31.maven</groupId>
+				<artifactId>scala-maven-plugin</artifactId>
+				<executions>
+					<execution>
+						<id>scala-compile-first</id>
+						<phase>process-resources</phase>
+						<goals>
+							<goal>add-source</goal>
+							<goal>compile</goal>
+						</goals>
+					</execution>
+					<execution>
+						<id>scala-test-compile</id>
+						<phase>process-test-resources</phase>
+						<goals>
+							<goal>testCompile</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+	</build>
+
+</project>
Index: src/main/java/com/tai/demo/test/ThreadTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/test/ThreadTest.java	(date 1601283861977)
+++ src/main/java/com/tai/demo/test/ThreadTest.java	(date 1601283861977)
@@ -0,0 +1,85 @@
+package com.tai.demo.test;
+
+/**
+ * @description: 多线程demo
+ * @author: Taylor
+ * @date :  2020-09-28 16:06
+ **/
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+public class ThreadTest {
+
+
+    /**
+     * 主线程
+     */
+    public static void main(String[] args) {
+
+        //开启10个多线程
+        int threadCount = 10;
+
+        //所有线程阻塞，然后统一开始
+        CountDownLatch begin = new CountDownLatch(1);
+
+        //主线程阻塞，直到所有分线程执行完毕
+        CountDownLatch end = new CountDownLatch(threadCount);
+
+        //开始多线程
+        begin.countDown();
+        for (Integer i = 0; i < threadCount; i++) {
+            Runnable runnable = dealSomeThing(i,begin,end);
+            new Thread(runnable).start();
+        }
+
+        //多个线程都执行结束
+        try {
+            end.await();
+            System.out.println("多个线程都执行结束，可以做自己的事情了");
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+            System.out.println("多线程执行中出错了，凉凉了！！！");
+        }
+    }
+
+
+    /**
+     * 工作线程
+     * 本方法  是在构造多线程要做的事情
+     *
+     * =====================可以做的事===================
+     * 当然可以传入ConcurrentHashMap之类的线程安全的 类
+     * 来记录线程中的处理结果之类的
+     * 最后 在多线程都执行完了以后 就可以对处理结果进行操作了
+     * ==================================================
+     *
+     * @param threadNum 当前线程编号
+     * @param begin
+     * @param end
+     * @return
+     */
+    private static Runnable dealSomeThing(int threadNum, CountDownLatch begin, CountDownLatch end){
+        Runnable runnable = new Runnable() {
+            @Override
+            public void run() {
+
+                try {
+                    System.out.println("线程"+threadNum+":--------------------->开始工作");
+                    System.out.println("线程"+threadNum+"做具体的事情,比如去service调用 具体的方法做什么操作之类的");
+                    TimeUnit.SECONDS.sleep(10);
+
+                    end.countDown();
+                    System.out.println("线程"+threadNum+":--------------------->结束工作");
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+
+            }
+        };
+        return runnable;
+    }
+
+
+
+
+}
\ No newline at end of file
Index: src/main/java/com/tai/demo/test/MultiThreadTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/test/MultiThreadTest.java	(date 1603674642955)
+++ src/main/java/com/tai/demo/test/MultiThreadTest.java	(date 1603674642955)
@@ -0,0 +1,153 @@
+package com.tai.demo.test;
+
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * @description: 多线程测试
+ * @author: Taylor
+ * @date :  2020-10-12 09:07
+ **/
+public class MultiThreadTest {
+
+    private static final int MAX_THREAD_NUM = 5;
+
+    public static void main(String[] args){
+
+        try {
+            fixedThread();
+//            dynamicThread();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static ArrayList getList(){
+        List<Integer> idList = new ArrayList<>();
+        for (int i = 0; i < 11; i++) {
+            idList.add(i);
+        }
+        return (ArrayList) idList;
+    }
+    /**
+     * 线程数固定方式
+     * @throws InterruptedException
+     */
+    public static void fixedThread() throws InterruptedException {
+
+        ArrayList idList = getList();
+
+        int threadNum = MAX_THREAD_NUM;
+        if( idList.size() < MAX_THREAD_NUM){
+            threadNum = idList.size();
+        }
+        System.out.println("开启的总线程数 :"+threadNum);
+        ExecutorService executorService = Executors.newFixedThreadPool(threadNum);
+        CountDownLatch countDownLatch = new CountDownLatch(threadNum);
+
+        //除数的整数
+        int intNum = idList.size()/MAX_THREAD_NUM;
+        //取模余数大小
+        int remainderNum = idList.size()%MAX_THREAD_NUM;
+        int initNum = remainderNum*(intNum+1);
+        for (int i = 0; i < threadNum; i++) {
+            MultiThread thread = new MultiThread();
+            if( idList.size() < MAX_THREAD_NUM){
+                thread.setIdList(idList.subList(i,i+1));
+            }else{
+                if(i < remainderNum ){
+                    thread.setIdList(idList.subList(i * (intNum+1), (i + 1) * (intNum+1)));
+                    System.out.println( "第 "+(i+1)+ "循环，处理任务数："+(intNum+1));
+                }else {
+                    thread.setIdList(idList.subList(initNum+(i-remainderNum)*intNum, initNum+(i-remainderNum+1)*intNum));
+                    System.out.println("第 "+(i+1)+ "循环，处理任务数："+intNum);
+                }
+            }
+            thread.setCountDownLatch(countDownLatch);
+            executorService.submit(thread);
+        }
+        countDownLatch.await();
+        executorService.shutdown();
+    }
+
+    /**
+     * 线程数动态计算方式
+     * @throws InterruptedException
+     */
+    public static void dynamicThread() throws InterruptedException {
+
+        ArrayList idList = getList();
+
+        int threadNum = MAX_THREAD_NUM;
+        if( idList.size() < MAX_THREAD_NUM){
+            threadNum = idList.size();
+        }
+        int perSize = 0;
+        if(idList.size() % threadNum == 0){
+            perSize = idList.size() / threadNum;
+        }else{
+            perSize = idList.size() / threadNum +1;
+        }
+        threadNum =(idList.size()-1)/perSize+1;
+
+        System.out.println("开启的总线程数 :"+threadNum);
+        ExecutorService executorService = Executors.newFixedThreadPool(threadNum);
+        CountDownLatch countDownLatch = new CountDownLatch(threadNum);
+
+        System.out.println("每个线程最多处理的数据:"+perSize);
+        for (int i = 0; i < threadNum; i++) {
+            MultiThread thread = new MultiThread();
+            if( idList.size() < MAX_THREAD_NUM){
+                thread.setIdList(idList.subList(i,i+1));
+            }else{
+                if((i + 1) * perSize>idList.size()){
+                    thread.setIdList(idList.subList(i * perSize, idList.size()));
+                }else {
+                    thread.setIdList(idList.subList(i * perSize, (i + 1) * perSize));
+                }
+            }
+            thread.setCountDownLatch(countDownLatch);
+            executorService.submit(thread);
+        }
+
+        countDownLatch.await();
+        executorService.shutdown();
+    }
+
+
+     static class MultiThread implements Runnable {
+        private List<Integer> idList;
+
+        private CountDownLatch countDownLatch;
+
+        @Override
+        public void run() {
+            System.out.println(Thread.currentThread().getName() +" 线程开启........");
+            try {
+                Thread.sleep(1000);
+                System.out.println(this.idList.toString());
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                if (countDownLatch != null) {
+                    countDownLatch.countDown();
+                }
+            }
+            System.out.println(Thread.currentThread().getName() +" 线程结束........ 还有 "+countDownLatch.getCount()+" 线程");
+        }
+
+        public void setIdList(List<Integer> idList) {
+            this.idList = idList;
+        }
+
+        public void setCountDownLatch(CountDownLatch countDownLatch) {
+            this.countDownLatch = countDownLatch;
+        }
+
+    }
+
+}
Index: src/main/java/com/tai/demo/test/WatchThread.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/test/WatchThread.java	(date 1601195854648)
+++ src/main/java/com/tai/demo/test/WatchThread.java	(date 1601195854648)
@@ -0,0 +1,100 @@
+package com.tai.demo.test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * 
+ * @author Administrator
+ *
+ */
+public class WatchThread {
+	
+	/**
+	 * 测试函数
+	 * 
+	 * @throws InterruptedException
+	 */
+	public void testThread() throws InterruptedException {
+		
+		//首先查出所有效标签
+		int allNum = 26;//数据总量
+		int num = 5; //单个线程5个标签
+		
+//		int threadNum =(int)Math.ceil(allNum/100);
+		int threadNum =(allNum-1)/num+1;
+		
+		// 初始化countDown
+		CountDownLatch threadSignal = new CountDownLatch(threadNum);
+		// 创建固定长度的线程池
+//		Executor executor = Executors.newFixedThreadPool(threadNum);
+		//此处不可以用接口 需要使用Executor的实现类 ExecutorService  Executor未提供shutdown等方法
+		ExecutorService executor = Executors.newFixedThreadPool(threadNum);
+		for (int i = 1; i  < threadNum+1; i++) { // 开threadNum个线程
+			String tableName="ce_u_label_index";
+			tableName+=i;
+			Runnable task = new TestThread(threadSignal,tableName);
+			// 执行
+			executor.execute(task);
+			
+		}
+		threadSignal.await(); // 等待所有子线程执行完
+		//固定线程池执行完成后 将释放掉资源 退出主进程
+		executor.shutdown();//并不是终止线程的运行，而是禁止在这个Executor中添加新的任务
+		// do work end
+		//退出主进程
+		System.out.println(Thread.currentThread().getName() + "+++++++结束.");
+	}
+ 
+	/**
+	 * 测试函数
+	 */
+	public static void main(String[] args) throws InterruptedException {
+		WatchThread test = new WatchThread();
+		test.testThread();
+	}
+ 
+	/**
+	 * 内部类
+	 * 作为内部类的时候 有一个好处 就是可以直接引用给类的主对象的成员变量 
+	 *
+	 */
+	private class TestThread implements Runnable {
+		private CountDownLatch threadsSignal;
+		private String tableName;
+ 
+		
+		public TestThread(CountDownLatch threadsSignal, String tableName) {
+			super();
+			this.threadsSignal = threadsSignal;
+			this.tableName = tableName;
+		}
+ 
+		public void run() {
+			System.out.println(Thread.currentThread().getName() + "开始..." + tableName);
+			System.out.println("开始了线程：：：：" + threadsSignal.getCount());
+		
+			//核心处理逻辑
+			try {
+				/**
+				 * 根据传过来的表名取查询插入该表的基本表
+				 * Oracle表中配置了基本表和临时表的关系
+				 * 
+				 */
+				TimeUnit.SECONDS.sleep(5);
+			} catch (InterruptedException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		    //	用到成员变量name作为参数
+			
+			// 线程结束时计数器减1
+			threadsSignal.countDown();//必须等核心处理逻辑处理完成后才可以减1
+			System.out.println(Thread.currentThread().getName() + "结束. 还有"
+					+ threadsSignal.getCount() + " 个线程");
+		}
+	}
+
+}
Index: src/main/java/com/tai/demo/domain/Book.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/domain/Book.java	(date 1599525222850)
+++ src/main/java/com/tai/demo/domain/Book.java	(date 1599525222850)
@@ -0,0 +1,35 @@
+package com.tai.demo.domain;
+
+import org.springframework.boot.context.properties.ConfigurationProperties;
+import org.springframework.stereotype.Component;
+
+@Component
+@ConfigurationProperties(prefix = "book")
+public class Book {
+
+	private String name;
+	private String author;
+	private int age;
+	
+	public String getName() {
+		return name;
+	}
+	public void setName(String name) {
+		this.name = name;
+	}
+	
+	public String getAuthor() {
+		return author;
+	}
+	public void setAuthor(String author) {
+		this.author = author;
+	}
+	public int getAge() {
+		return age;
+	}
+	public void setAge(int age) {
+		this.age = age;
+	}
+	
+	
+}
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README.md	(date 1603854102886)
+++ README.md	(date 1603854102886)
@@ -0,0 +1,5 @@
+本项目依赖springboot框架编写
+
+1 hbase demo
+
+2 spark demo
\ No newline at end of file
Index: src/main/java/com/tai/demo/controller/Mycontroller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/controller/Mycontroller.java	(date 1599530537883)
+++ src/main/java/com/tai/demo/controller/Mycontroller.java	(date 1599530537883)
@@ -0,0 +1,21 @@
+package com.tai.demo.controller;
+
+
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+import com.tai.demo.domain.Book;
+
+@RestController
+public class Mycontroller {
+	
+	@Autowired
+	private Book book;
+
+	
+	@RequestMapping("/")
+	public String index() {
+		return "作者："+book.getAuthor()+"  书名："+book.getName()+" 作者年龄："+book.getAge();
+	}
+}
Index: src/main/java/com/tai/demo/test/TestDemo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/test/TestDemo.java	(date 1601278921382)
+++ src/main/java/com/tai/demo/test/TestDemo.java	(date 1601278921382)
@@ -0,0 +1,44 @@
+package com.tai.demo.test;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+public class TestDemo {
+
+	public static void main(String[] args) {
+
+		int num = 5;
+		int oldSize = 4;
+		int newSize= 3;
+
+		int x = 0;
+		List oldlist = new ArrayList<>();
+		for (int i = 0; i < oldSize; i++) {
+			String oldTable = "old_";
+			if (i%num==0){
+				x+=1;
+			}
+			oldTable+=x;
+			System.out.println("oldtable:"+oldTable);
+			oldlist.add(oldTable);
+		}
+		System.out.println(oldlist.toString());
+		int y = 0;
+		List newlist = new ArrayList<>();
+		for (int i = 0; i < newSize; i++) {
+			String newTable = "new_";
+			if (i%num==0){
+				y+=1;
+			}
+			newTable+=y;
+			System.out.println("newtable:"+newTable);
+			newlist.add(newTable);
+		}
+		System.out.println(newlist.toString());
+
+/*		for (int i = 0; i <100; i++) {
+			System.out.println((int) ((Math.random()*9+1)*10000) );
+		}*/
+	}
+}
Index: src/main/java/com/tai/demo/common/CustomServletContainer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/tai/demo/common/CustomServletContainer.java	(date 1599548021934)
+++ src/main/java/com/tai/demo/common/CustomServletContainer.java	(date 1599548021934)
@@ -0,0 +1,24 @@
+package com.tai.demo.common;
+
+import org.springframework.boot.web.server.WebServerFactory;
+import org.springframework.boot.web.server.WebServerFactoryCustomizer;
+import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
+import org.springframework.context.annotation.Bean;
+
+public class CustomServletContainer implements WebServerFactoryCustomizer<WebServerFactory>{
+
+	@Override
+	public void customize(WebServerFactory factory) {
+		// TODO Auto-generated method stub
+		
+	}
+	@Bean
+    public WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> webServerFactoryCustomizer(){
+        return new WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>() {
+            @Override
+            public void customize(ConfigurableServletWebServerFactory factory) {
+                factory.setPort(8090);
+            }
+        };
+    }
+}
